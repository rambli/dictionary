#include"trie.h"
#include"reader.h"
#include"../hashtable/htbl.h"

trie_node *new_trie_node()
{
   static int count = 0;
   trie_node *node = NULL;
   node = (trie_node*)malloc(sizeof(trie_node));
   count++;
#if 0
   if(!(count % 10))
      printf("nc: %d\n", count);
#endif
   return (node);
}

void createTrie(trie_node **trie)
{
   if(NULL == trie)
      return;
   *trie = new_trie_node();
   if(!(*trie))
      return;
   int iter = NUM_NODES;
   do
   {
      (*trie)->link[iter] = NULL;
   }while(--iter);
}

void addNode(trie_node **head, char data)
{
   if(!(*head))
   {
      *head = new_trie_node();
      (*head)->data = data;
      printf("Added %c\n", (*head)->data);
   }
   else
   {
      printf("%c->", (*head)->data);
      addNode(&((*head)->link[GET_INDEX(data)]), data);
   }
}

void addEntry(trie_node **head, char *str)
{
   if(!str)
      return;
   int len = strlen(str) + 1;
 
   /* Setup head if NULL */
   if(!(*head))
   {
      createTrie(head);
      (*head)->data = *str;
      //printf("\n(new head) %c\n", (*head)->data);
      str++;
      len--;
   }
   else
   {
      str++;
      len--;
   }
   trie_node *add = *head;

   do
   {
      /* If link is NULL, add a new one and assign it data.
       * If link already present, don't add a node and just skip to 
       * next char to be added and the following node. */
      if(!add->link[GET_INDEX(*str)])
      {
         add->link[GET_INDEX(*str)] = new_trie_node();
         add->link[GET_INDEX(*str)]->data = *str;
      //   printf("(new) %c", *str);
      }
      //else
      //{
      //   printf("(old) %c", *str);
      //}
      //printf("->");
      /* Increment str and get next node */
      add = add->link[GET_INDEX(*str)];
      str++;
   }while(--len);
   //printf("\n");
}

void freeTrie(trie_node **head)
{
   static int free_count = 0;
   int i = 0;
   if(!(*head))
      return;
   for(i = 0; i < NUM_NODES; i++)
   {
      if((*head)->link[i])
      {
         freeTrie(&((*head)->link[i]));
      }
   }
   free(*head);
   *head = NULL;
   free_count++;
#if 0 
   if(!(free_count % 10))
      printf("fc:%d\n", free_count);
#endif
}

void freeAllTries(trie_node **head)
{
   int j = 0;
   /* Free all nodes from all trees */
   for(j = 0; j < 27; j++)
   {
      if(head[j])
      {
         freeTrie(&head[j]);
      }
   }
}

bool isStrPresent(trie_node *head, char *str)
{
   if(!head || !str)
      return;
   int len = strlen(str) + 1;
   do
   {
      if(head->data != *str)
         break;
      str++;
      head = head->link[GET_INDEX(*str)];
      len--;
   }while(len && head);
   if(!len)
      return TRUE;
   return FALSE;
}

bool isSubString(trie_node *head, char *string)
{
   if(!head || !string)
      return;
   while(*string && head)
   {
      if(head->data == (char)*string)
      {
         string++;
         head = head->link[GET_INDEX(*string)];
      }
   }
   if(!*string)
      return TRUE;
   return FALSE;
}

int main()
{
   /* Replace this with a hash table */
   trie_node **head = NULL;
   /* Reader to read tokens */
   reader *dict_rdr = NULL;
   /* Reader to read words generated by module */
   reader *word_rdr = NULL;
   /* Hashtable to store dictionary */
   //htbl *hash = NULL;
   int i = 0;
   char buffer[26];
   dict_rdr = newReader("dictionary.txt");
   if(!dict_rdr)
      goto LBL_EXIT;

   //hash = initHash(26);
   //if(!hash)
   //   goto LBL_EXIT;

   /* Create temp local hash-table */
   head = (trie_node**) calloc(26, sizeof(trie_node));

   while(1)
   {
      dict_rdr->getNextToken(dict_rdr, buffer);
      if(buffer[0] == '\0')
      {
         printf("No more strings\n");
         break;
      }
      addEntry(&head[GET_INDEX(buffer[0])], buffer);
      memset(buffer, 0, sizeof(buffer));
   }

   printf("Done creating dictionary tree\n");

   /* Open words file to cross-reference against our dictionary trie */
   word_rdr = newReader("OUT");
   if(!word_rdr)
      goto LBL_EXIT;

   char buf[26];
   int j = 2188;
   while(j--)
   {
      word_rdr->getNextToken(word_rdr, buf);
      if(isStrPresent(head[GET_INDEX(buf[0])], buf))
         printf("Valid word: %s\n", buf);
      memset(buf, 0, sizeof(buf));
   }
LBL_EXIT:
   freeAllTries(head);
   /* Close reader as we are done reading tokens */
   if(dict_rdr)
   {
      dict_rdr->unInit(dict_rdr);
      dict_rdr = NULL;   
   }
   if(word_rdr)
   {
      word_rdr->unInit(word_rdr);
      word_rdr = NULL;
   }
   /*
   if(hash)
   {
      hash->freeHash(hash);
      hash = NULL;
   }
   */
   free(head);
}
